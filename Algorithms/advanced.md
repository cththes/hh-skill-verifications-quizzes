# Алгоритмы и структуры данных
15 правильных вопросов из 15 (09.2025)

# Вопрос 1
В проекте по обработке данных ваша команда столкнулась с проблемой: текущая сортировка работает слишком медленно, а загрузка системы выросла до критического уровня. Анализ логов показал, что алгоритм выполняет многочисленные копирования данных и плохо масштабируется на многопоточных системах.
Как решить эту проблему с помощью алгоритма сортировки?

Ответы:
1. Применить сортировку слиянием для разделения работы между потоками ✓
2. Применить сортировку вставками для локального улучшения производительности
3. Использовать пузырьковую сортировку для упрощения алгоритма
4. Переключиться на сортировку выбором для минимизации операций копирования
5. Применить поразрядную сортировку для минимизации операций сравнения

Правильный ответ: 1.


# Вопрос 2
Вы разрабатываете систему поиска данных в большом неупорядоченном массиве, где необходимо значительно сократить время поиска

Вы определили для себя такие условия:
1. Использование линейного поиска приводит к временной сложности O(n), что делает его неэффективным для больших объемов данных.
2. Размер массива составляет 1 миллиард записей, что требует высокой производительности алгоритма.
3. Среднее время отклика на запрос не должно превышать 1 миллисекунду.

Какой подход к организации поиска позволит обеспечить лучшую производительность в заданных условиях?

Ответы:
1. Добавить хеш-таблицу для быстрого поиска за O(1) ✓
2. Применить бинарный поиск для значительного ускорения
3. Разделить массив на равные части и применять поиск последовательности
4. Переключиться на жадный алгоритм поиска, который обходит только часть массива
5. Использовать индексы и частичную предвыборку для ускоренного поиска

Правильный ответ: 1.


# Вопрос 3
В вашей системе для хранения и обработки больших объемов данных используются динамические массивы. С ростом данных стали очевидны проблемы с производительностью, обусловленные частым перераспределением памяти.
Что произойдёт после перехода на массив с резервированием памяти?

Ответы:
1. Уменьшится количество перераспределений памяти, но при этом возрастёт сложность поиска нужных элементов
2. Увеличится средняя скорость вставки новых элементов в массив за счёт уменьшения числа перераспределений ✓
3. Значительно возрастёт расход оперативной памяти, так как массив будет занимать больше места в системе
4. Операции удаления станут быстрее, поскольку освободившаяся память сразу вернётся в общий пул системы
5. Ускорится процесс сортировки массива, потому что данные будут размещаться более равномерно в памяти

Правильный ответ 2.


# Вопрос 4
Вы работаете с системой логирования, где важна строгая очередность обработки событий. Однако в системе наблюдаются блокировки, когда сразу несколько процессов пытаются обработать данные одновременно, что приводит к задержкам при высокой нагрузке.
Почему использование lock-free очереди позволяет устранить блокировки и ускорить работу системы?

Ответы:
1. Lock-free алгоритмы автоматически балансируют нагрузку между потоками, распределяя задачи равномерно
2. Lock-free структуры данных в полной мере используют атомарные операции ✓
3. Lock-free структуры позволяют избежать проблем с приоритетным инверсированием при многопоточном доступе
4. Lock-free очереди полностью исключают конкурентный доступ к данным
5. Lock-free структуры данных используют специальные буферы

Правильный ответ 2.


# Вопрос 5
Вы оптимизировали код, использующий быструю сортировку (Quicksort). Однако в некоторых случаях производительность алгоритма оказалась хуже, чем у сортировки вставками, особенно на больших наборах данных.
Почему это могло произойти?

Ответы:
1. Использование нерекурсивного подхода могло принципиально изменить поведение алгоритма
2. Неудачный выбор опорного элемента, из-за которого алгоритм мог деградировать до O(N^2), если разбиение происходит неравномерно ✓
3. Оптимизация кеширования могла существенно снизить своевременный доступ при работе алгоритма к необходимым данным
4. Выбран неподходящий компилятор, который не влияет напрямую на алгоритмическую сложность сортировки
5. Применение multithreading могло повлиять на параллельную производительность и общую базовую сложность алгоритма

Правильный ответ 2.


# Вопрос 6
В системе обработки данных связные списки используются для хранения информации, однако анализ производительности выявил высокие задержки при выполнении операций поиска.

Исследование показало, что:
1. Среднее время поиска элемента в связном списке составляет O(n), что становится узким местом при увеличении объема данных.
2. Вставка и удаление работают быстро (O(1) при наличии указателя), но это не компенсирует замедленный поиск.
3. Важно не только ускорить поиск, но и учесть влияние выбора структуры данных на затраты памяти и сложность обновления данных.

Каков будет эффект перехода на альтернативную структуру данных и к чему это приведет?

Ответы:
1. Хеш-таблицы ускорят поиск, но приведут к росту затрат памяти из-за хранения хешей и возможных коллизий
2. Двусвязные списки улучшат последовательный доступ, но не решат проблему случайного поиска
3. Переход на сбалансированные деревья повысит скорость поиска, но увеличит вычислительные затраты на вставку и удаление ✓
4. Кольцевой буфер ускорит потоковую обработку, но не облегчит решение задачи произвольного доступа к необходимым данным
5. Использование динамических массивов уменьшит накладные расходы, но замедлит операции вставки и удаления

Правильный ответ 3.


# Вопрос 7
Вы разрабатываете алгоритм прогнозирования финансовых показателей, в котором используется вычисление чисел Фибоначчи для моделирования временных рядов. Однако анализ производительности показывает, что при больших значениях вычисления выполняются крайне медленно, что делает модель непригодной для реального использования.
Что могло привести к такой низкой производительности?

Ответы:
1. Замена рекурсивного решения на итеративное снижает сложность, что приводит к экспоненциальной сложности
2. Использование рекурсии без мемоизации увеличивает количество вызовов, что приводит к экспоненциальной сложности ✓
3. Удаление условий выхода из рекурсии приводит к бесконечным вызовам и объясняет рост сложности
4. Использование хвостовой рекурсии снижает потребление памяти и создает проблему экспоненциальных вычислений
5. Добавление кеша для хранения промежуточных результатов повышает скорость и вызывает низкую производительность

Правильный ответ 2.


# Вопрос 8
В системе автоматической навигации для логистической компании, в которой маршруты грузового транспорта строятся автоматически, граф дорог представлен взвешенным ориентированным графом, а алгоритм расчета оптимальных маршрутов основан на поиске кратчайшего пути. Тестирование выявило две ключевые проблемы:
- При увеличении числа точек доставки время расчета маршрутов резко возрастает, что приводит к задержкам в системе.
- Один и тот же граф при повторном запуске алгоритма дает разные корректные маршруты, но их длина различается, что вызывает колебания времени доставки.

Примеры расхождений:
В первом тесте маршрут от S до Т проходит через А -> С -> Е -> Т.
В другом тесте для той же конфигурации графа, но с измененным порядком обработки узлов маршрут изменился на S -> B -> D -> T.

Какое изменение в алгоритме или структуре графа могло привести к такому поведению?

Ответы:
1. Изменение структуры данных хранения графа
2. Приоритет обработки узлов в очереди изменил порядок выбора пути ✓
3. Использование алгоритма поиска в глубину вместо алгоритма Дейкстры
4. Добавление новых ребер с другими весами нарушило исходную маршрутизацию
5. Использование эвристики при выборе ребер

Правильный ответ 2.


# Вопрос 9
Вы разрабатываете распределенную систему обработки данных, в которой хеш-таблица используется для быстрого доступа к записи журнала событий. После развертывания на тестовом окружении было выявлено, что время поиска отдельных записей значительно увеличивается по мере накопления данных. Дополнительный анализ показал, что в таблице образуется несколько «горячих» бакетов, содержащих непропорционально большое число элементов, что приводит к росту времени поиска.
Какой фактор вызывает такой рост?

Ответы:
1. Использование плохой хеш-функции, приводящей к неравномерному распределению ключей ✓
2. Ограничение глубины цепочек в методе цепочного хеширования
3. Добавление большего количества бакетов приводит к сильному росту коллизий
4. Применение связных списков внутри бакетов исключает возможность накопления элементов в одном сегменте
5. Рехеширование таблицы после каждой вставки значительно ускоряет доступ

Правильный ответ 1.


# Вопрос 10
Какой фактор точно ухудшит распределение ключей и снизит производительность хеш-таблицы?

Ответы:
1. Использование хеш-функции, возвращающей одно значение ✓
2. Применение метода цепочек без ограничения длины
3. Хеширование ключей делением значений на фиксированное число
4. Выбор размера хеш-таблицы, кратного степени двойки
5. Использование хеш-функции, игнорирующей часть ключа

Правильный ответ 1.


# Вопрос 11
Вам нужно оптимизировать размещения данных в кэш-памяти, чтобы выбирать наиболее ценные и часто используемые данные при ограниченном объеме доступной памяти. Алгоритм пересчитывает одни и те же значения многократно, что приводит к избыточным вычислениям.
Что нужно сделать, чтобы уменьшить количество избыточных вычислений?

Ответы:
1. Реализовать эвристический алгоритм, который сокращает ненужные вычисления
2. Применить жадный алгоритм для оптимального выбора часто используемых данных
3. Использовать кэш с ограниченным объемом, обновляемый по стратегии LRU
4. Добавить мемоизацию для сохранения необходимых промежуточных результатов ✓
5. Кешировать только последние вычисленные значения, игнорируя промежуточные результаты

Правильный ответ 4.


# Вопрос 12
Вы разрабатываете систему навигации для транспортной компании, которая оптимизирует маршруты грузоперевозок между городами. Тестирование показало, что при увеличении количества точек доставки время расчета маршрутов резко возрастает, что приводит к задержкам в системе.
Как можно оптимизировать поиск маршрутов?

Ответы:
1. Применить алгоритм полного перебора, чтобы учесть все маршруты
2. Использовать алгоритм А* с эвристиками для ускорения поиска ✓
3. Настроить использование неориентированного графа вместо ориентированного
4. Удалить ребра с большим весом, чтобы сократить количество проверок
5. Использовать DFS для поиска кратчайшего пути

Правильный ответ 2.


# Вопрос 13
Анализ кода выявил, что одни и те же подзадачи пересчитываются многократно, что приводит к экспоненциальному росту времени выполнения.
Как динамическое программирование помогает ускорить вычисления?

Ответы:
1. Использует рекурсию без кеширования для минимизации затрат памяти
2. Удаляет повторяющиеся символы перед вычислением, чтобы ускорить работу
3. Перебирает не все возможные подпоследовательности, а только четные
4. Заменяет строки на хеш-значения для уменьшения сложности и роста скорости
5. Заполняет таблицу размером O(n * m), избегая повторных вычислений ✓

Правильный ответ 5.


# Вопрос 14
Какой ключевой аспект отличает метод Беллмана-Форда при поиске кратчайших путей в разреженном взвешенном графе, содержащем как положительные, так и отрицательные рёбра, но без циклов отрицательного веса?

Ответы:
1. Обрабатывает полный набор возможных сочетаний узлов одновременно, вычисляя все наилучшие значения в графе
2. Позволяет находить оптимальные маршруты даже при наличии снижающих стоимость переходов, корректируя расстояния на каждом шаге ✓
3. Одновременно обрабатывает все возможные пути, вычисляя кратчайшие расстояния за один шаг
4. Формирует минимальное остовное дерево, минимизируя суммарный вес соединений в графе
5. Принимает приближенные оценки, ускоряя процесс за счет сокращения полного количества анализируемых вариантов

Правильный ответ 2.


# Вопрос 15
Какой метод НЕ является оптимальным для решения задачи линейного программирования с жесткими ограничениями?

Ответы:
1. Использование динамического программирования для разбиения задачи на подпроблемы
2. Применение метода градиентного спуска для оптимизации многомерных функций
3. Применение симплекс-метода для нахождения глобального оптимального решения
4. Использование линейного поиска для нахождения допустимых значений переменных
5. Использование жадного алгоритма, который принимает локально оптимальные решения на каждом шаге ✓

Правильный ответ 5.


02.10 (11 правильных ответов из 15)
# Вопрос 16
Вы разрабатываете систему поиска в структуре данных с динамическими изменениями, такой как граф или дерево, где необходимо учитывать изменяющуюся структуру.

Вы определили для себя такие условия:
1. Количество узлов может достигать 100 миллионов, и связи между узлами изменяются в реальном времени
2. Алгоритм поиска должен минимизировать затраты на обновление структуры данных
3. Важно учитывать динамические изменения при выборе наиболее подходящего метода поиска

Что применить, чтобы обеспечить наилучшую производительность при этих условиях?

Ответы:
1. Учитывать сложность динамических изменений структуры данных и выбирать алгоритм, минимизирующий затраты на обновления
2. Применить жадный алгоритм (например, жадный поиск A) без учета изменений структуры
3. Выбирать алгоритм, который будет эффективен только при статической структуре данных
4. Рассматривать использование многократных индексаций и предварительных вычислений для ускорения поиска
5. Оценить стоимость всех возможных путей в графе с учетом возможных циклов и их влияния на скорость поиска

Выбрал ответ: 1


# Вопрос 17
В вашем проекте требуется организовать структуру данных для эффективного выполнения операций поиска, добавления и удаления элементов при высоких нагрузках.

Вам известно следующее:
1. Объем данных превышает 10 миллионов записей
2. Система ограничена в оперативной памяти (не более 1 ГБ)
3. Средняя нагрузка — 100 тысяч операций в минуту
4. Требуется минимизировать задержки при поиске и обновлении данных

Почему в условиях этого сценария хеш-таблица может оказаться неидеальным решением, несмотря на высокую скорость выполнения операций?

Ответы:
1. Поиск в хеш-таблице невозможен без точного знания ключа, что усложняет обработку данных с иерархической структурой
2. Хеш-таблица увеличивает время доступа к данным в условиях конкурентного использования памяти с множеством параллельных потоков
3. Хеш-таблица требует хранения хешей и связей, что увеличивает потребление памяти, особенно при использовании методов открытой адресации
4. Упорядоченный обход элементов невозможен, что делает хеш-таблицы неэффективными в задачах, требующих итерационного поиска по диапазону
5. Значительные накладные расходы на разрешение коллизий могут привести к росту времени поиска в худших случаях

Выбрал ответ: 3. Возможна ошибка.


# Вопрос 18
В системе потоковой аналитики все входящие события обрабатываются через одну глобальную очередь. После увеличения числа потоков и нагрузки были зафиксированы:
- Рост времени отклика
- Ухудшение масштабируемости
- Падение кэш-локальности

Почему производительность системы снизилась, несмотря на увеличение количества потоков?

Ответы:
1. FIFO-поведение очереди блокирует новые задачи до завершения старых, что вызывает задержки
2. Глобальная очередь становится точкой конкуренции, увеличивая накладные расходы на синхронизацию
3. Добавление потоков увеличивает контекстные переключения, нарушая предсказуемость выполнения
4. Очередь с блокировкой не позволяет потокам использовать кеш-память эффективно
5. Очередь организована как стек, что нарушает порядок поступления задач

Выбрал ответ: 2


# Вопрос 19
Вам необходимо в реальном времени обрабатывать огромный поток логов, поступающих от нескольких серверов. Для ускорения процесса вы внедрили новый алгоритм фильтрации и предобработки данных.

В результате оказалось, что:
1. Система начала использовать избыточный объем оперативной памяти, в разы превышающий расчетные пределы.
2. Среднее время ответа сервиса выросло настолько, что пользователи стали получать данные с ощутимой задержкой.

Выберите наиболее вероятное объяснение, почему это произошло.

Ответы:
1. Новый алгоритм включает сложный механизм динамической оптимизации, который проводит предварительный анализ данных, что приводит к снижению скорости и росту памяти
2. При разработке алгоритма не учли реальную асимптотическую сложность по времени и памяти; после роста объема логов начались массовые перераспределения памяти и увеличение числа операций
3. Задержки неизбежны при любой фильтрации логов в реальном времени. Повышение потребления говорит о недостаточном количестве модулей оперативной памяти, что замедляет алгоритм
4. Задержки в обработке логов возникли из-за того, что новый алгоритм автоматически увеличивает глубину рекурсии при росте нагрузки, что повлияло на память и среднее время ответа
5. Алгоритм был протестирован на больших объемах данных, но в другом окружении, поэтому эффекты высокой параллельности по объему оперативной памяти и времени ответа не проявились заранее

Выбрал ответ: 2


# Вопрос 20
Ваше приложение обрабатывает миллиарды записей в реальном времени, но система неожиданно начала потреблять больше памяти, чем было рассчитано. Логирование показало, что значительная часть памяти уходит на накладные расходы структуры данных.

Что наиболее вероятно приводит к повышенному расходу памяти?

Ответы:
1. Замена динамического выделения памяти на статическое
2. Использование сжатия данных
3. Ограничение числа одновременно загруженных структур данных
4. Применение memory-mapped файлов
5. Использование деревьев поиска вместо хеш-таблиц

Выбрал ответ: 3. Возможна ошибка (ответ 5)


# Вопрос 21
Вы разрабатываете рекурсивный алгоритм обработки данных, который выполняет вложенные вызовы. Однако при больших объемах входных данных время выполнения увеличивается нелинейно.

Исследование показало, что:
- Алгоритм пересчитывает одни и те же значения на каждом уровне рекурсии.
- При увеличении объема данных сложность алгоритма растет быстрее, чем ожидается.

Какой фактор наиболее вероятно приводит к росту времени выполнения?

Ответы:
1. Использование глобальных переменных снижает производительность из-за необходимости синхронизации при каждом вызове
2. Передача больших объектов между рекурсивными вызовами увеличивает нагрузку на стек и замедляет алгоритм
3. Оптимизации, выполняемые компилятором, могут непредсказуемо изменять порядок вычислений и замедлять выполнение
4. Отсутствие кэширования промежуточных результатов приводит к увеличению сложности алгоритма
5. Рекурсивные вызовы с глубокой вложенностью требуют больше памяти и могут привести к превышению лимита стека

Выбрал ответ: 5. Возможна ошибка (ответ 4)


# Вопрос 22
Вы анализируете логи работы алгоритма Дейкстры, используемого в навигационной системе умного города. Полученные маршруты вызывают сомнения, и вам нужно определить, соответствует ли структура графа требованиям алгоритма.

В вашей программе после выполнения алгоритма Дейкстры лог системы вывел следующий путь: A → C → F → H → G

Какие выводы можно сделать о структуре графа и корректности работы алгоритма, основываясь на данном маршруте?

Ответы:
1. Алгоритм Дейкстры использует жадный метод, выбирая ближайшую вершину на каждом шаге пути
2. Маршрут мог быть построен некорректно из-за возможного наличия циклов в графе
3. Наличие отрицательных ребер могло бы привести к ошибкам в алгоритме Дейкстры
4. Один выбранный маршрут не дает полной информации о числе связей у вершин графа
5. Граф направленный, все ребра имеют положительные веса, а сам алгоритм отработал корректно

Выбрал ответ: 5


# Вопрос 23
Вы проектируете систему хранения и обработки логов в распределенной среде, где хеш-таблица используется для быстрого доступа к журналу событий.

После развертывания в продакшене обнаружилось следующее:
1. Время доступа к данным в таблице начало расти нелинейно, несмотря на увеличение количества серверов.
2. Частота коллизий в бакетах возросла, что подтвердилось анализом распределения ключей.
3. Операции поиска отдельных записей стали значительно медленнее при высоких нагрузках.

Дополнительное исследование показало, что избыточное наполнение данных в некоторых бакетах приводит к замедлению поиска, а стратегия разрешения коллизий больше не обеспечивает равномерного распределения.

Какая причина может объяснить такую деградацию производительности?

Ответы:
1. Применение избыточного рехеширования, которое увеличило нагрузку на CPU
2. Ограничение количества бакетов, которое вызвало переполнение существующих сегментов
3. Использование случайного пробирования при линейном разрешении коллизий
4. Перенос части данных в хранилище на диске, что замедлило доступ к таблице
5. Использование слабой хеш-функции, создающей неравномерное распределение ключей
Выбрал ответ: 5. Возможна ошибка (ответ 3)!


# Вопрос 24
Какой фактор НЕ влияет на борьбу с коллизиями в хеш-таблицах?

Ответы:
1. Выбор метода разрешения коллизий, возникающих при обработке хеш-таблицы
2. Оптимизация внутренней структуры хранения данных при возникновении коллизий
3. Использование качественной хеш-функции для равномерного распределения данных
4. Использование многопоточной обработки для параллельного доступа к таблице
5. Динамическое увеличение размера таблицы при превышении порога заполнения

Выбрал ответ: 4


# Вопрос 25
Вы разрабатываете алгоритм для поиска минимального количества разрезов строки, необходимых для разбиения ее на палиндромы. Первоначальная версия использует рекурсивный подход, но при длинных строках время выполнения возрастает экспоненциально. Проверка показала, что некоторые подстроки анализируются несколько раз, что приводит к значительным накладным расходам.

Какой метод поможет уменьшить избыточные вычисления и повысить производительность?

Ответы:
1. Применить жадный алгоритм разбиения строк, снизив число рассмотренных вариантов
2. Использовать динамическое программирование для хранения уже рассчитанных разрезов
3. Использовать алгоритм полного перебора для точного расчета оптимального варианта
4. Добавить дополнительный уровень предобработки строк перед разбиением
5. Увеличить глубину рекурсии для детального анализа каждого возможного разбиения

Выбрал ответ: 2


# Вопрос 26
Вы разрабатываете систему для оптимизации маршрутов в компьютерной сети, где стоимость передачи данных между узлами может быть как положительной (стандартные затраты на их передачу), так и отрицательной (например, провайдер платит компенсацию за использование определенных каналов или выдает бонусы за использование вами не основных, а резервных линий). Таким образом, для вас часть передач между такими узлами не увеличивает общую стоимость, а уменьшает ее. Отрицательные веса на ребрах графа означают, что использование определенных каналов снижает общую стоимость передачи данных. Однако при тестировании алгоритма Дейкстры вы обнаружили, что он выдает некорректные маршруты.

Какой подход позволит корректно учитывать отрицательные веса на ребрах графа и находить оптимальные маршруты?

Ответы:
1. Использовать алгоритм Беллмана-Форда вместо Дейкстры
2. Применить жадный алгоритм для поиска альтернативных маршрутов
3. Удалить отрицательные ребра перед запуском алгоритма
4. Ограничить число итераций алгоритма, чтобы избежать ошибок
5. Игнорировать отрицательные веса, обрабатывая их как нулевые

Выбрал ответ: 1


# Вопрос 27
При решении задачи о размене суммы с помощью заданных номиналов монет используется динамическое программирование. Результатом работы алгоритма должно быть количество различных способов собрать целевую сумму.

Что позволяет избежать повторных вычислений в таком алгоритме?

Ответы:
1. Хранение ранее вычисленных значений подзадач и их повторное использование
2. Использование рекурсивного перебора без сохранения промежуточных результатов
3. Ограничение количества номиналов и удаление избыточных комбинаций
4. Переход от итерации к жадному выбору с округлением до ближайшего делителя

Выбрал ответ: 1


# Вопрос 28
Почему алгоритм Дейкстры не подходит для поиска кратчайшего пути в графе с отрицательными весами?

Ответы:
1. Алгоритм Дейкстры потребует матрицы смежности для таких весов
2. Время выполнения алгоритма слишком велико для таких задач
3. Жадная стратегия не учитывает отрицательные веса корректно
4. Алгоритм использует неэффективное кеширование путей
5. В этом случае алгоритм не будет работать в ориентированных графах

Выбрал ответ: 3

# Алгоритмы и структуры данных
12 правильных ответов из 15 (10.2025)

[Вопросы 1-15 остаются без изменений]

# Вопрос 29
Вы работаете с распределенной системой, которая обрабатывает миллионы записей. При попытке внедрить быструю сортировку (quicksort) в условиях параллельной обработки на нескольких узлах результаты оказались нестабильными. Время выполнения варьируется, и на некоторых узлах наблюдается перегрузка памяти.

Какой подход следует выбрать, чтобы обеспечить детерминированное поведение и равномерную нагрузку при масштабировании сортировки?

Ответы:
1. Включить механизм кеширования на уровне системы ввода-вывода
2. Использовать параллельное слияние после завершения сортировки на каждом узле
3. Выбрать алгоритм сортировки слиянием для его детерминированности
4. Переходить на более мелкие пакеты данных и выполнять их последовательную сортировку
5. Настроить сбалансированное распределение нагрузки между узлами

Выбрал ответ: 3


# Вопрос 30
Вы проектируете систему для обработки и хранения больших объемов данных, в которой структура данных будет изменяться динамически (например, частые добавления, удаления и модификации данных).

Почему следует учесть дополнительные факторы при выборе структуры данных для такой системы в условиях высокой нагрузки и частых изменений?

Ответы:
1. Выбор структуры данных должен учитывать сложность реализации, так как слишком сложные структуры могут усложнить поддержку и развитие системы, увеличивая затраты на разработку, отладку и масштабирование, даже если они обладают высокой теоретической эффективностью
2. Правильная структура данных позволяет минимизировать использование памяти и эффективно управлять динамическими изменениями в реальном времени, обеспечивая масштабируемость при увеличении объема данных
3. Так как ресурсы системы всегда ограничены, следует выбирать структуру данных, которая сбалансирует между требованиями к производительности и оптимизацией памяти, избегая избыточных операций и снижая нагрузку на процессор и память
4. Эффективное управление памятью и временем при динамических изменениях минимизирует накладные расходы на операции и улучшает общую производительность системы, позволяя работать с большими объемами данных при высоких нагрузках
5. Неподходящая структура данных может значительно замедлить выполнение операций вставки, удаления и модификации, что вызовет увеличение времени отклика системы

Выбрал ответ: 2


# Вопрос 31
В банковской системе реализован механизм вложенных транзакций с возможностью отмены (undo). Однако в нагрузочном тестировании выявлены проблемы:
- Задержки при отмене вложенных операций
- Рост потребления памяти при большом числе параллельных транзакций
- Трудности с поддержанием корректного порядка отмены

С чем связаны эти проблемы в реализации?

Ответы:
1. Хранение каждой транзакции в отдельной очереди с приоритетом по времени
2. Передача управления транзакциями через сигналы и таймеры в разных потоках
3. Попытка реализовать undo через FIFO буфер с ручной очисткой
4. Использование общего глобального стека без разграничения уровней транзакций
5. Реализация вложенных операций через связанные списки без указателей на родителя

Выбрал ответ: 4


# Вопрос 32
В вашей компании, занимающейся анализом логов (журналов событий) с нескольких серверов, долгое время применялся метод опорных векторов (SVM) для классификации записей.

Однако объемы данных продолжали расти, и вы решили перейти на логистическую регрессию, чтобы ускорить процесс обучения и упростить масштабирование. По результатам тестов выяснилось, что логистическая регрессия действительно обучается быстрее, но итоговая точность может заметно колебаться в зависимости от структуры и размера поступающих логов.

С учетом того, что решение принималось не как выбор ML-модели, а как архитектурная замена ресурсоёмкого алгоритма на более масштабируемый, в чем причина таких изменений?

Ответы:
1. Логистическая регрессия требует значительно большего объема памяти при работе с большими логами, что негативно влияет на точность модели
2. Логистическая регрессия автоматически масштабирует признаки и всегда работает с изменчивой точностью за O(log n), независимо от структуры данных
3. Логистическая регрессия сильно зависит от линейной разделимости данных, и если данные не линейно разделимы, точность меняется в зависимости от структуры и размера логов
4. Логистическая регрессия не учитывает размер выборки и сохраняет постоянно колеблющуюся точность при обучении независимо от объема и размера логов
5. Логистическая регрессия по определению применима только к симметрично распределённым данным и не может адаптироваться к неравномерной выборке

Выбрал ответ: 3


# Вопрос 33
В вашей системе управления данными связные списки используются для хранения и обработки информации. Однако при частом доступе к произвольным элементам производительность системы существенно снизилась. Было предложено несколько решений для ускорения поиска.

Какое из них не позволит существенно повысить скорость без значительного увеличения накладных расходов?

Ответы:
1. Использование пропускных списков, так как оно ускоряет поиск, но требует усложненной логики вставки и удаления, что увеличивает накладные расходы
2. Использование дополнительной индексации, так как оно увеличивает скорость поиска, но требует значительных затрат памяти на хранение вспомогательных структур
3. Замена односвязного списка на двусвязный, так как она позволяет быстрее перемещаться назад и не ускоряет поиск в целом, а лишь увеличивает расход памяти
4. Применение хеш-таблицы, так как оно ускоряет доступ к данным, но требует вычислений для поддержки коллизий и увеличивает сложность управления памятью
5. Связный список, так как он требует последовательного обхода элементов, что делает поиск по произвольному индексу медленным в сравнении с массивами

Выбрал ответ: 1


# Вопрос 34
В многопоточной системе запущен рекурсивный алгоритм, который работает с большим количеством данных. Однако при увеличении нагрузки время отклика системы резко возрастает, а потребление памяти выходит за установленные лимиты.

Исследование выявило:
1. Рекурсивные вызовы продолжают накапливаться в стеке при увеличении объема входных данных.
2. Некоторые потоки завершаются с ошибкой переполнения памяти.
3. Система замедляется при выполнении глубоких рекурсивных вычислений.

Что может быть основной причиной этого поведения?

Ответы:
1. Рекурсивные вызовы с большой глубиной не могут быть оптимизированы компилятором
2. Использование статических переменных приводит к увеличенному потреблению памяти при каждом вызове
3. Использование конкурентного доступа к памяти увеличивает задержки в системе
4. Ограничение количества потоков уменьшает общую пропускную способность
5. Отсутствие хвостовой рекурсии приводит к накоплению вызовов в стеке

Выбрал ответ: 5


# Вопрос 35
Выберите вариант ответа, в котором перечислены только ключевые метрики, определяющие производительность хеш-таблицы.

Ответы:
1. Размер таблицы, количество операций вставки, использование связных списков
2. Процент занятых ячеек, число доступных бакетов, время вычисления хеш-функции
3. Распределение данных, максимальная длина цепочки, сложность хеш-функции
4. Коэффициент загрузки, количество коллизий, среднее время нахождения данных
5. Частота рехеширования, глубина пробирования, общее число записей

Выбрал ответ: 4


# Вопрос 36
В вашей компании разрабатывается интеллектуальная система распределения грузов по железной дороге, в которой используется граф с динамически изменяющимися тарифами. Некоторые тарифы, например, небольшие скидки на весь маршрут за включение обратного рейса или скидки за остановку на таможенную проверку груза на этой станции могут иметь отрицательные веса. В тестах ваш алгоритм дал корректные результаты.

Что изменить, чтобы тесты НЕ дали корректные результаты с отрицательными весами?

Ответы:
1. Добавить рёбра с очень большими положительными весами
2. Заменить вариант ранее используемого алгоритма на алгоритм Дейкстры
3. Применить модификацию алгоритма Флойда-Уоршелла, которая заменяет отрицательные рёбра на положительные
4. Ограничить глубину поиска маршрутов, чтобы предотвратить влияние отрицательных рёбер
5. Запретить использование вершин с отрицательными весами

Выбрал ответ: 5


# Вопрос 37
В задаче планирования расходов и выбора оптимального набора проектов с ограниченным бюджетом ваша итоговая реализация медленная и потребляет много памяти. Заполняется таблицу полностью, включая значения, которые никогда не используются.

Какой принцип динамического программирования позволяет избежать лишних вычислений и тем самым ускоряет алгоритм?

Ответы:
1. Хранение и повторное использование только нужных промежуточных значений
2. Применение вероятностной оценки значимости подзадач при выборе направлений
3. Создание рекурсивной модели с максимальной глубиной вызова
4. Переход на жадную стратегию выбора решений без сохранения таблицы
5. Хранение только глобального максимума без промежуточной истории

Выбрал ответ: 1


# Вопрос 38
Какая общая черта присуща как генетическим алгоритмам, так и симплекс-методу при решении задач оптимизации?

Ответы:
1. Использование скользящего массива для хранения только необходимых промежуточных данных
2. Опора на полный перебор всех возможных решений для гарантированного нахождения оптимума
3. Применение метода "разделяй и властвуй" для разбиения задачи на независимые подзадачи
4. Итеративный процесс улучшения решения, на каждом шаге присутствует попытка найти лучший вариант
5. Использование исключительно детерминированных правил перехода между состояниями для достижения решения

Выбрал ответ: 4

# Устаревшие вопросы

# Вопрос 39 (устаревший)
Вы реализовали рекурсивную функцию для подсчёта количества маршрутов, по которым складской робот может добраться от точки приёма до точки упаковки. Робот перемещается по сетке из 20 строк и 20 столбцов, двигаясь только вправо или вниз. Алгоритм корректно работает на малых размерах сетки, но при запуске на полном размере программа резко теряет производительность: выполнение занимает очень много времени, хотя объём используемой памяти остаётся стабильным.

Почему выполнение алгоритма резко замедляется при увеличении размера сетки, несмотря на стабильное потребление памяти?

Ответы:
1. Алгоритм многократно пересчитывает одни и те же подзадачи, поскольку не сохраняет промежуточные результаты ✓
2. Алгоритм перебирает маршруты с возвратами назад, увеличивая число комбинаций
3. Происходит переполнение переменной, в которую записывается итоговое значение
4. Используется хвостовая рекурсия, которая замедляет выполнение на больших входных данных
5. Глубина рекурсии превышает лимит стека, вызывая остановку выполнения

Правильный ответ 1


# Вопрос 40 (устаревший)
В модуле сравнения текстов вы реализовали рекурсивную функцию, вычисляющую длину наибольшей общей подпоследовательности (LCS) для двух строк длиной до 10 000 символов каждая. Профилировщик показал, что функция тратит большую часть времени на повторные вычисления одних и тех же подзадач многократно сравниваются одни и те же префиксы строк.

Какой приём позволит радикально сократить время работы алгоритма, сохранив корректный результат?

Ответы:
1. Переписать алгоритм в итеративном стиле, полностью отказавшись от рекурсии, без хранения промежуточных результатов
2. Сохранять результаты уже решённых подзадач (мемоизация) и переиспользовать их при повторных вызовах ✓
3. Кешировать только последние удачные совпадения символов, игнорируя остальные подзадачи
4. Использовать «жадный» выбор: сразу добавлять любой совпавший символ, если он встречается в обеих строках
5. Ограничить глубину рекурсии фиксированным порогом, прерывая вычисления при его достижении

Правильный ответ 2
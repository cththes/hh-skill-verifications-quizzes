# Алгоритмы и структуры данных
15 правильных вопросов из 15 (09.2025)

# Вопрос 1
В проекте по обработке данных ваша команда столкнулась с проблемой: текущая сортировка работает слишком медленно, а загрузка системы выросла до критического уровня. Анализ логов показал, что алгоритм выполняет многочисленные копирования данных и плохо масштабируется на многопоточных системах.
Как решить эту проблему с помощью алгоритма сортировки?

Ответы:
1. Применить сортировку слиянием для разделения работы между потоками ✓
2. Применить сортировку вставками для локального улучшения производительности
3. Использовать пузырьковую сортировку для упрощения алгоритма
4. Переключиться на сортировку выбором для минимизации операций копирования
5. Применить поразрядную сортировку для минимизации операций сравнения

Правильный ответ: 1.


# Вопрос 2
Вы разрабатываете систему поиска данных в большом неупорядоченном массиве, где необходимо значительно сократить время поиска

Вы определили для себя такие условия:
1. Использование линейного поиска приводит к временной сложности O(n), что делает его неэффективным для больших объемов данных.
2. Размер массива составляет 1 миллиард записей, что требует высокой производительности алгоритма.
3. Среднее время отклика на запрос не должно превышать 1 миллисекунду.

Какой подход к организации поиска позволит обеспечить лучшую производительность в заданных условиях?

Ответы:
1. Добавить хеш-таблицу для быстрого поиска за O(1) ✓
2. Применить бинарный поиск для значительного ускорения
3. Разделить массив на равные части и применять поиск последовательности
4. Переключиться на жадный алгоритм поиска, который обходит только часть массива
5. Использовать индексы и частичную предвыборку для ускоренного поиска

Правильный ответ: 1.


# Вопрос 3
В вашей системе для хранения и обработки больших объемов данных используются динамические массивы. С ростом данных стали очевидны проблемы с производительностью, обусловленные частым перераспределением памяти.
Что произойдёт после перехода на массив с резервированием памяти?

Ответы:
1. Уменьшится количество перераспределений памяти, но при этом возрастёт сложность поиска нужных элементов
2. Увеличится средняя скорость вставки новых элементов в массив за счёт уменьшения числа перераспределений ✓
3. Значительно возрастёт расход оперативной памяти, так как массив будет занимать больше места в системе
4. Операции удаления станут быстрее, поскольку освободившаяся память сразу вернётся в общий пул системы
5. Ускорится процесс сортировки массива, потому что данные будут размещаться более равномерно в памяти

Правильный ответ 2.



# Вопрос 4
Вы работаете с системой логирования, где важна строгая очередность обработки событий. Однако в системе наблюдаются блокировки, когда сразу несколько процессов пытаются обработать данные одновременно, что приводит к задержкам при высокой нагрузке.
Почему использование lock-free очереди позволяет устранить блокировки и ускорить работу системы?

Ответы:
1. Lock-free алгоритмы автоматически балансируют нагрузку между потоками, распределяя задачи равномерно
2. Lock-free структуры данных в полной мере используют атомарные операции ✓
3. Lock-free структуры позволяют избежать проблем с приоритетным инверсированием при многопоточном доступе
4. Lock-free очереди полностью исключают конкурентный доступ к данным
5. Lock-free структуры данных используют специальные буферы

Правильный ответ 2.



# Вопрос 5
Вы оптимизировали код, использующий быструю сортировку (Quicksort). Однако в некоторых случаях производительность алгоритма оказалась хуже, чем у сортировки вставками, особенно на больших наборах данных.
Почему это могло произойти?

Ответы:
1. Использование нерекурсивного подхода могло принципиально изменить поведение алгоритма
2. Неудачный выбор опорного элемента, из-за которого алгоритм мог деградировать до O(N^2), если разбиение происходит неравномерно ✓
3. Оптимизация кеширования могла существенно снизить своевременный доступ при работе алгоритма к необходимым данным
4. Выбран неподходящий компилятор, который не влияет напрямую на алгоритмическую сложность сортировки
5. Применение multithreading могло повлиять на параллельную производительность и общую базовую сложность алгоритма

Правильный ответ 2.



# Вопрос 6
В системе обработки данных связные списки используются для хранения информации, однако анализ производительности выявил высокие задержки при выполнении операций поиска.

Исследование показало, что:
1. Среднее время поиска элемента в связном списке составляет O(n), что становится узким местом при увеличении объема данных.
2. Вставка и удаление работают быстро (O(1) при наличии указателя), но это не компенсирует замедленный поиск.
3. Важно не только ускорить поиск, но и учесть влияние выбора структуры данных на затраты памяти и сложность обновления данных.

Каков будет эффект перехода на альтернативную структуру данных и к чему это приведет?

Ответы:
1. Хеш-таблицы ускорят поиск, но приведут к росту затрат памяти из-за хранения хешей и возможных коллизий
2. Двусвязные списки улучшат последовательный доступ, но не решат проблему случайного поиска
3. Переход на сбалансированные деревья повысит скорость поиска, но увеличит вычислительные затраты на вставку и удаление ✓
4. Кольцевой буфер ускорит потоковую обработку, но не облегчит решение задачи произвольного доступа к необходимым данным
5. Использование динамических массивов уменьшит накладные расходы, но замедлит операции вставки и удаления

Правильный ответ 3.



# Вопрос 7
Вы разрабатываете алгоритм прогнозирования финансовых показателей, в котором используется вычисление чисел Фибоначчи для моделирования временных рядов. Однако анализ производительности показывает, что при больших значениях вычисления выполняются крайне медленно, что делает модель непригодной для реального использования.
Что могло привести к такой низкой производительности?

Ответы:
1. Замена рекурсивного решения на итеративное снижает сложность, что приводит к экспоненциальной сложности
2. Использование рекурсии без мемоизации увеличивает количество вызовов, что приводит к экспоненциальной сложности ✓
3. Удаление условий выхода из рекурсии приводит к бесконечным вызовам и объясняет рост сложности
4. Использование хвостовой рекурсии снижает потребление памяти и создает проблему экспоненциальных вычислений
5. Добавление кеша для хранения промежуточных результатов повышает скорость и вызывает низкую производительность

Правильный ответ 2.



# Вопрос 8
В системе автоматической навигации для логистической компании, в которой маршруты грузового транспорта строятся автоматически, граф дорог представлен взвешенным ориентированным графом, а алгоритм расчета оптимальных маршрутов основан на поиске кратчайшего пути. Тестирование выявило две ключевые проблемы:
- При увеличении числа точек доставки время расчета маршрутов резко возрастает, что приводит к задержкам в системе.
- Один и тот же граф при повторном запуске алгоритма дает разные корректные маршруты, но их длина различается, что вызывает колебания времени доставки.

Примеры расхождений:
В первом тесте маршрут от S до Т проходит через А -> С -> Е -> Т.
В другом тесте для той же конфигурации графа, но с измененным порядком обработки узлов маршрут изменился на S -> B -> D -> T.

Какое изменение в алгоритме или структуре графа могло привести к такому поведению?

Ответы:
1. Изменение структуры данных хранения графа
2. Приоритет обработки узлов в очереди изменил порядок выбора пути ✓
3. Использование алгоритма поиска в глубину вместо алгоритма Дейкстры
4. Добавление новых ребер с другими весами нарушило исходную маршрутизацию
5. Использование эвристики при выборе ребер

Правильный ответ 2.



# Вопрос 9
Вы разрабатываете распределенную систему обработки данных, в которой хеш-таблица используется для быстрого доступа к записи журнала событий. После развертывания на тестовом окружении было выявлено, что время поиска отдельных записей значительно увеличивается по мере накопления данных. Дополнительный анализ показал, что в таблице образуется несколько «горячих» бакетов, содержащих непропорционально большое число элементов, что приводит к росту времени поиска.
Какой фактор вызывает такой рост?

Ответы:
1. Использование плохой хеш-функции, приводящей к неравномерному распределению ключей ✓
2. Ограничение глубины цепочек в методе цепочного хеширования
3. Добавление большего количества бакетов приводит к сильному росту коллизий
4. Применение связных списков внутри бакетов исключает возможность накопления элементов в одном сегменте
5. Рехеширование таблицы после каждой вставки значительно ускоряет доступ

Правильный ответ 1.



# Вопрос 10
Какой фактор точно ухудшит распределение ключей и снизит производительность хеш-таблицы?

Ответы:
1. Использование хеш-функции, возвращающей одно значение ✓
2. Применение метода цепочек без ограничения длины
3. Хеширование ключей делением значений на фиксированное число
4. Выбор размера хеш-таблицы, кратного степени двойки
5. Использование хеш-функции, игнорирующей часть ключа

Правильный ответ 1.



# Вопрос 11
Вам нужно оптимизировать размещения данных в кэш-памяти, чтобы выбирать наиболее ценные и часто используемые данные при ограниченном объеме доступной памяти. Алгоритм пересчитывает одни и те же значения многократно, что приводит к избыточным вычислениям.
Что нужно сделать, чтобы уменьшить количество избыточных вычислений?

Ответы:
1. Реализовать эвристический алгоритм, который сокращает ненужные вычисления
2. Применить жадный алгоритм для оптимального выбора часто используемых данных
3. Использовать кэш с ограниченным объемом, обновляемый по стратегии LRU
4. Добавить мемоизацию для сохранения необходимых промежуточных результатов ✓
5. Кешировать только последние вычисленные значения, игнорируя промежуточные результаты

Правильный ответ 4.



# Вопрос 12
Вы разрабатываете систему навигации для транспортной компании, которая оптимизирует маршруты грузоперевозок между городами. Тестирование показало, что при увеличении количества точек доставки время расчета маршрутов резко возрастает, что приводит к задержкам в системе.
Как можно оптимизировать поиск маршрутов?

Ответы:
1. Применить алгоритм полного перебора, чтобы учесть все маршруты
2. Использовать алгоритм А* с эвристиками для ускорения поиска ✓
3. Настроить использование неориентированного графа вместо ориентированного
4. Удалить ребра с большим весом, чтобы сократить количество проверок
5. Использовать DFS для поиска кратчайшего пути

Правильный ответ 2.



# Вопрос 13
Анализ кода выявил, что одни и те же подзадачи пересчитываются многократно, что приводит к экспоненциальному росту времени выполнения.
Как динамическое программирование помогает ускорить вычисления?

Ответы:
1. Использует рекурсию без кеширования для минимизации затрат памяти
2. Удаляет повторяющиеся символы перед вычислением, чтобы ускорить работу
3. Перебирает не все возможные подпоследовательности, а только четные
4. Заменяет строки на хеш-значения для уменьшения сложности и роста скорости
5. Заполняет таблицу размером O(n * m), избегая повторных вычислений ✓

Правильный ответ 5.



# Вопрос 14
Какой ключевой аспект отличает метод Беллмана-Форда при поиске кратчайших путей в разреженном взвешенном графе, содержащем как положительные, так и отрицательные рёбра, но без циклов отрицательного веса?

Ответы:
1. Обрабатывает полный набор возможных сочетаний узлов одновременно, вычисляя все наилучшие значения в графе
2. Позволяет находить оптимальные маршруты даже при наличии снижающих стоимость переходов, корректируя расстояния на каждом шаге ✓
3. Одновременно обрабатывает все возможные пути, вычисляя кратчайшие расстояния за один шаг
4. Формирует минимальное остовное дерево, минимизируя суммарный вес соединений в графе
5. Принимает приближенные оценки, ускоряя процесс за счет сокращения полного количества анализируемых вариантов

Правильный ответ 2.



# Вопрос 15
Какой метод НЕ является оптимальным для решения задачи линейного программирования с жесткими ограничениями?

Ответы:
1. Использование динамического программирования для разбиения задачи на подпроблемы
2. Применение метода градиентного спуска для оптимизации многомерных функций
3. Применение симплекс-метода для нахождения глобального оптимального решения
4. Использование линейного поиска для нахождения допустимых значений переменных
5. Использование жадного алгоритма, который принимает локально оптимальные решения на каждом шаге ✓

Правильный ответ 5.



# Устаревшие вопросы

# Вопрос 16
Вы реализовали рекурсивную функцию для подсчёта количества маршрутов, по которым складской робот может добраться от точки приёма до точки упаковки. Робот перемещается по сетке из 20 строк и 20 столбцов, двигаясь только вправо или вниз. Алгоритм корректно работает на малых размерах сетки, но при запуске на полном размере программа резко теряет производительность: выполнение занимает очень много времени, хотя объём используемой памяти остаётся стабильным.

Почему выполнение алгоритма резко замедляется при увеличении размера сетки, несмотря на стабильное потребление памяти?

Ответы:
1. Алгоритм многократно пересчитывает одни и те же подзадачи, поскольку не сохраняет промежуточные результаты ✓
2. Алгоритм перебирает маршруты с возвратами назад, увеличивая число комбинаций
3. Происходит переполнение переменной, в которую записывается итоговое значение
4. Используется хвостовая рекурсия, которая замедляет выполнение на больших входных данных
5. Глубина рекурсии превышает лимит стека, вызывая остановку выполнения

Правильный ответ 1



# Вопрос 17
В модуле сравнения текстов вы реализовали рекурсивную функцию, вычисляющую длину наибольшей общей подпоследовательности (LCS) для двух строк длиной до 10 000 символов каждая. Профилировщик показал, что функция тратит большую часть времени на повторные вычисления одних и тех же подзадач многократно сравниваются одни и те же префиксы строк.

Какой приём позволит радикально сократить время работы алгоритма, сохранив корректный результат?

Ответы:
1. Переписать алгоритм в итеративном стиле, полностью отказавшись от рекурсии, без хранения промежуточных результатов
2. Сохранять результаты уже решённых подзадач (мемоизация) и переиспользовать их при повторных вызовах ✓
3. Кешировать только последние удачные совпадения символов, игнорируя остальные подзадачи
4. Использовать «жадный» выбор: сразу добавлять любой совпавший символ, если он встречается в обеих строках
5. Ограничить глубину рекурсии фиксированным порогом, прерывая вычисления при его достижении

Правильный ответ 2.
13.10, 12 верных ответов из 15.

**Вопрос 1:**
Какое значение НЕ будет выведено в консоль после выполнения следующего кода?
```javascript
const user = { name: "Alice", age: 25 };
function updateUser(obj) {
  obj.age = 30;
  const user = { name: "Bob", age: 40 };
  console.log(user.name);
  console.log(user.age);
}
updateUser(user);
console.log(user.age);
console.log(user.name);
```
Варианты: 
1. "Bob"
2. 40
3. 30
4. Alice"
5. 25
**Правильный ответ:** 25

**Вопрос 2:**
При разработке защищённого интернет-банкинга требуется временное хранение промежуточных вычислений и результатов транзакций. Эти данные не должны сохраняться после завершения работы с приложением, чтобы снизить риск несанкционированного доступа и обеспечить безопасность конфиденциальной информации.

Какой тип хранилища вы подберете для данной задачи?
Варианты: 
1. IndexedDB
2. LocalStorage
3. Cookies
4. SessionStorage
5. Service Worker Cache
**Выбранный ответ:** IndexedDB
**Вероятный верный ответ:** SessionStorage

**Вопрос 3:**
Каким будет результат выполнения следующего выражения в JavaScript?
`2 + '2' - '1'`
Варианты: 
1. 21
2. 221
3. 4
4. 3
5. NaN
**Правильный ответ:** 21

**Вопрос 4:**
Дан массив строк с числами. Необходимо оставить строки, содержащие четное число, преобразовать их в числа и вычислить произведение. Какой код это выполняет?
Варианты:
1. numbers.reduce((p, n) => p + (n % 2 === 0 ? n : 1), 1)
2. numbers.map(n => n % 2 === 0 ? Number(n) : 1).reduce((p, n) => p * n, 0)
3. numbers.forEach(n => { if (Number(n) % 2 === 0) n = Number(n) * n })
4. numbers.filter(n => +n % 2 === 0).map(Number).reduce((p, n) => p * n, 1)
5. numbers.filter(n => +n % 2 !== 0).map(Number).reduce((p, n) => p * n, 1)
**Правильный ответ:** `numbers.filter(n => +n % 2 === 0).map(Number).reduce((p, n) => p * n, 1)`

**Вопрос 5:**
Какая функция наследует лексическое окружение от места своего объявления и не имеет собственного this?
Варианты: 
1. Функция-конструктор
2. Стрелочная функция
3. Асинхронная функция
4. Функция обратного вызова
5. Генераторная функция
**Выбранный ответ:** Стрелочная функция

**Вопрос 6:**
Что будет выведено в консоль при выполнении данного кода?
```javascript
let baseValue = 10;
function buildIncrementer(step) {
  return function() {
    baseValue += step;
    return baseValue;
  };
}
const incBy3 = buildIncrementer(3);
console.log(incBy3());
console.log(incBy3());
baseValue = 100;
console.log(incBy3());
```
Варианты: 
1. 13, 13, 13;
2. 103, 106, 109;
3. 13, 16, 19;
4. NaN, NaN, NaN;
5. 13, 16, 103
**Правильный ответ:** 13, 16, 103

**Вопрос 7:**
В какой последовательности выполняются операции в следующем коде, который включает асинхронные операции и взаимодействие с сетью? Учтите, что обработка запроса не будет закончена до того, как выполнится весь синхронный код программы.

```javascript
async function getData() {
  console.log("Начинаем запрос");
  const response = await fetch("https://api.example.com/data");
  console.log("После await");
  const data = await response.json();
  console.log("Данные:", data);
}
console.log("Синхронный 1");
getData();
console.log("Синхронный 2");
```

**Варианты ответов:**

1. Начинаем запрос, Синхронный 1, Синхронный 2, После await, Данные: ...
2. Синхронный 1, Начинаем запрос, Синхронный 2, Данные: ..., После await
3. Синхронный 1, Синхронный 2, Начинаем запрос, После await, Данные: ...
4. Начинаем запрос, После await, Данные: ..., Синхронный 1, Синхронный 2
5. Синхронный 1, Начинаем запрос, Синхронный 2, После await, Данные: ...

**Правильный ответ:** Синхронный 1, Начинаем запрос, Синхронный 2, После await, Данные: ...

**Вопрос 8:**
Вы хотите объединить свойства двух объектов и элементы двух массивов, при этом для объектов нужно сохранить методы, хранящиеся как собственные свойства, а для массивов исключить дубликаты. Как лучше всего добиться этого?
Варианты: 
1. const mergedObj = {...obj1}; mergedObj.proto = obj2; const mergedArr = Array.from(new Set([...arr1, ...arr2]));
2. const mergedObj = {...obj1, ...obj2}; const mergedArr = [...new Set([...arr1, ...arr2])];
3. const mergedObj = JSON.parse(JSON.stringify(obj1, obj2)); const mergedArr = [...arr1, ...arr2];
4. const mergedObj = Object.assign(obj1, obj2); const mergedArr = arr1.push(...arr2);
5. const mergedObj = Object.create(obj2, Object.getOwnPropertyDescriptors(obj1)); const mergedArr = [...arr1.filter(x => !arr2.includes(x)), ...arr2];
**Правильный ответ:** `const mergedObj = {...obj1, ...obj2}; const mergedArr = [...new Set([...arr1, ...arr2])];`

**Вопрос 9:**
У вас есть следующий код. Что будет выведено в консоль при его вызове?
```javascript
class CustomError extends Error {
  constructor(message, code) {
    super(message);
    this.code = code;
  }
  showError() {
    return `Ошибка [${this.code}]: ${this.message}`;
  }
}
function throwError() {
  throw new CustomError("Что-то пошло не так", 404);
}
try {
  throwError();
} catch (e) {
  console.log(e instanceof Error);
  console.log(e.showError());
}
```
Варианты: 
1. Выведется только true...;
2. Произойдет синтаксическая ошибка...;
3. Сначала в консоли отобразится true...;
4. Сначала в консоли отобразится false...;
5. Метод showError() вызовет рекурсию...
**Правильный ответ:** Сначала в консоли отобразится true, затем "Ошибка [404]: Что-то пошло не так"

**Вопрос 10:**
Какое из следующих утверждений о методе массива filter() верно?
Варианты: 
Какое из следующих утверждений о методе массива filter() верно?

Варианты ответа:

1. filter() создает и возвращает новый массив, содержащий только те элементы, для которых колбек-функция вернула true
2. filter() по умолчанию удаляет элементы массива, индексы которых кратны 2, даже если в переданном колбеке этого не указано
3. filter() перед выполнением фильтрации сначала автоматически сортирует массив в порядке возрастания, чтобы упростить поиск элементов
4. filter() возвращает логическое значение true или false в зависимости от того, прошли ли все элементы массива заданную проверку
5. filter() изменяет исходный массив, удаляя все элементы, которые не прошли проверку

**Выбранный ответ:** filter() создает и возвращает новый массив, содержащий только те элементы, для которых колбек-функция вернула true

**Вопрос 11:**
Вам необходимо вывести на одной странице большое количество текстовых записей. Как можно уменьшить нагрузку на сеть и ускорить первичную отрисовку элементов?
Варианты: 

1. Сразу загружать весь HTML-код элементов с сервера и вставлять его в DOM через innerHTML
2. Применить множественные таймеры setTimeout, чтобы разбивать процесс рендеринга на фрагменты
3. Использовать localStorage для хранения всех данных и загружать их при каждом обновлении страницы
4. Внедрить lazy loading для тяжёлых ресурсов, чтобы они подгружались только при необходимости
5. Загружать данные синхронно через fetch в цикле for, чтобы гарантированно отрендерить все элементы
**Выбранный ответ:** Применить множественные таймеры setTimeout, чтобы разбивать процесс рендеринга на фрагменты

**Вопрос 12:**
Что можно сказать о производительности и порядке выполнения следующего фрагмента кода, который включает асинхронные операции и взаимодействие с сетью? Учите, что обработка запроса не будет закончена до того, как выполнится весь синхронный код программы.
```javascript
console.log(1);
Promise.resolve()
  .then(() => {
    console.log(2);
    return Promise.resolve();
  })
  .then(() => {
    console.log(3);
  });
setTimeout(() => {
  console.log(4);
  setTimeout(() => {
    console.log(5);
  }, 0);
}, 0);
console.log(6);
```
Варианты: 
1. Обработка Promise происходит позже, чем setTimeout, поэтому 2 и 3 будут последними в порядке выполнения
2. Второй setTimeout может быть проигнорирован браузером, если страница неактивна
3. Promise.resolve() создаёт задержку в 0ms, что делает его эквивалентным setTimeout(..., 0)
4. Код покажет 2 и 3 до 4, потому что Promise.then() работает в микрозадачах, а setTimeout в макро
5. Вложенные setTimeout-ы могут при сильной нагрузке перепрыгнуть Promise, если очередь задержится
**Правильный ответ:** Код покажет 2 и 3 до 4, потому что Promise.then() работает в микрозадачах, а setTimeout в макро

**Вопрос 13:**
Для чего используется Rollup?
Варианты: 
1. Для выполнения кода напрямую в браузере без необходимости транспиляции
2. Для удобного разделения кода на чанки в крупных приложениях без дополнительной настройки
3. Для создания компактных бандлов через статический анализ зависимостей
4. Для автоматической подмены модулей без перезагрузки страницы во время разработки
5. Для генерации подробной документации по модулям, их структуре и зависимостям в проекте
**Выбранный ответ:** Для создания компактных бандлов через статический анализ зависимостей

**Вопрос 14:**
Как правильно назначить обработчик события изменения значения для `<input>`, используя фазу захвата?
Варианты: 
1. Назначить обработчик через свойство input.onchange
2. Применить метод input.attachEvent('onchange', callback)
3. Использовать input.addEventListener('change', callback)
4. Вызвать input.addEventListener('change', callback, true)
5. Привязать обработчик через jQuery-метод .change()
**Выбранный ответ:** Использовать input.addEventListener('change', callback)
**Вероятно верный ответ:** input.addEventListener('change', callback, true)

**Вопрос 15:**
При первой загрузке вашего SPA (Single Page Application) критичными являются определенные крупные ресурсы (например, шрифты, изображения, скрипты), отсутствие которых ухудшает пользовательский опыт.

Какой метод вы используете для достижения этой цели?
Варианты: 
1. Отложенная загрузка изображений с помощью Lazy Loading, чтобы загружать изображения только при их появлении в области видимости
2. Применение предварительной загрузки (preload) для критичных ресурсов, чтобы загружать важные файлы заранее
3. Динамическое разделение кода, чтобы загружать только необходимые модули и уменьшить размер бандла
4. Использование Web Workers для оптимизации загрузки, чтобы обрабатывать фоновые задачи без блокировки основного потока
5. Server-Side Rendering (SSR), чтобы рендерить контент на сервере и ускорить первый рендер страницы
**Выбранный ответ:** Применение предварительной загрузки (preload) для критичных ресурсов, чтобы загружать важные файлы заранее

13.10, 14 верных ответов из 15.

**Вопрос 16:**
Какое значение НЕ будет выведено в консоль после выполнения следующего кода?

```javascript
let message = "Hello";
const settings = { theme: "dark", language: "ru" };
settings.language = "en";
message = "Hey";
function test() {
  let message = "Hi";
  if (true) {
    const settings = { theme: "light", language: "fr" };
    settings.language = "es";
    console.log(settings.language);
  }
  console.log(message);
}
test();
console.log(settings.language);
console.log(message);
```

**Варианты ответа:**

1. "en"
2. "fr"
3. "Hey"
4. "Hi"
5. "es"

**Правильный ответ:** "fr"

**Вопрос: 17**
В современном веб-приложении социальной сети необходимо сохранять не только базовые настройки пользователя, но и сложные объекты (например, параметры отображения, избранный контент и настройки приватности). Данные должны храниться локально, поддерживать транзакционную целостность и масштабироваться с ростом объема информации, при этом не требуя постоянного обмена с сервером.

Какой тип хранилища вы подберете для данной задачи?

**Варианты ответа:**

1. LocalStorage
2. IndexedDB
3. Cookies
4. Web SQL Database
5. sessionStorage

**Выбранный ответ:** IndexedDB

**Вопрос: 18**
Каким будет результат выполнения следующего выражения в JavaScript?

**Варианты ответа:**
1. 710
2. '17'
3. 5
4. 15
5. '510'

**Выбранный ответ:** '510'

**Вопрос: 19**
В массиве объектов имеется свойство value. Какой код вычисляет сумму удвоенных значений, где value больше 5?

**Варианты ответа:**

1. `arr.filter(obj => obj.value > 5).reduce((s, obj) => s * 2 + obj.value, 0)`
2. `arr.map(obj => obj.value).filter(val => val > 5).reduce((s, val) => s + val, 0)`
3. `arr.reduce((s, obj) => obj.value > 5 ? s : s + obj.value * 2, 0)`
4. `arr.filter(obj => obj.value > 5).reduce((s, obj) => s + obj.value * 2, 0)`
5. `arr.map(obj => obj.value * 2).filter(val => val > 5).reduce((s, val) => s + val, 0)`

**Правильный ответ: 4** 
`arr.filter(obj => obj.value > 5).reduce((s, obj) => s + obj.value * 2, 0)`

**Вопрос: 20**
Что будет выведено в консоль при выполнении данного кода?

```javascript
const multiplier = (function(factor) {
  let counter = 1;
  return function(num) {
    counter *= factor;
    return num * counter;
  };
})(2);
console.log(multiplier(2));
console.log(multiplier(2));
console.log(multiplier(2));
```

**Варианты ответа:**

1. 4, 8, 16
2. 4, 6, 8
3. 2, 4, 6
4. 4, 16, 256
5. 4, 8, 8

**Правильный ответ:** 4, 8, 16

**Вопрос: 21**
В какой последовательности выполняются операции в следующем коде, который включает асинхронные операции и взаимодействие с сетью? Учтите, что обработка запроса не будет закончена до того, как выполнится весь синхронный код программы.

```javascript
console.log("Log A");
setTimeout(() => {
  console.log("Timeout 200ms");
}, 200);
fetch("https://api.example.com/check")
  .then(() => {
    console.log("Fetch check");
  });
setTimeout(() => {
  console.log("Timeout 0ms");
}, 0);
console.log("Log B");
```

**Варианты ответа:**

1. Log A, Log B, Timeout 200ms, Timeout 0ms, Fetch check
2. Log A, Fetch check, Log B, Timeout 0ms, Timeout 200ms
3. Log A, Log B, Timeout 0ms, Timeout 200ms, Fetch check
4. Log B, Log A, Timeout 0ms, Fetch check, Timeout 200ms
5. Log A, Log B, Timeout 200ms, Fetch check, Timeout 0ms

**Правильный ответ:** Log A, Log B, Timeout 0ms, Timeout 200ms, Fetch check

**Вопрос: 22**
Какое из следующих утверждений о методе Object.assign() является верным?

**Варианты ответа:**

1. Object.assign() автоматически удаляет свойства, содержащие функции, если они присутствуют в исходном объекте, так как методы не могут быть скопированы
2. Object.assign() выполняет глубокое копирование всех вложенных объектов по умолчанию, обеспечивая независимость копий от оригинала
3. Object.assign() копирует свойства из одного или нескольких исходных объектов в целевой объект, перезаписывая совпадающие свойства
4. Object.assign() выбрасывает ошибку, если целевой объект (target) уже содержит свойство с таким же именем, так как не может перезаписывать существующие значения
5. Object.assign() объединяет только свойства, у которых тип равен string; все остальные типы игнорируются

**Правильный ответ:** 3

**Вопрос:**
У вас есть следующий код. Что будет выведено в консоль при его вызове?

```javascript
class Person {
  constructor(name) {
    this._name = name;
  }
  get name() {
    return this._name;
  }
  set name(newName) {
    this._name = `Person: ${newName}`;
  }
}
class Employee extends Person {
  set name(newName) {
    // Вызываем сеттер родительского класса:
    super.name = newName;
    // Дополнительная логика
    console.log(`Сотрудник теперь называется ${this._name}`);
  }
}
const emp = new Employee("Анна");
emp.name = "Мария";
console.log(emp.name);
```

**Варианты ответа:**

1. Не будет выведено ничего, так как сеттер родителя переопределен дочерним и не вызывается вовсе
2. Код выведет только Person: Анна, потому что новое имя не присваивается
3. Результатом окажется Сотрудник теперь называется Person: Мария, затем undefined
4. Результатом окажется Сотрудник теперь называется Person: Анна, затем undefined
5. Будет выброшена ошибка TypeError: Cannot set property name of # <Employee>, так как нельзя обращаться к super.name

**Правильный ответ: 3** 
Результатом окажется Сотрудник теперь называется Person: Мария, затем undefined

**Вопрос: 23**
На странице со списком пользователей при прокрутке возникают лаги из-за многочисленных событий scroll. Как можно сократить влияние этих событий на производительность и сделать работу интерфейса плавнее?

**Варианты ответа:**

1. Создать дополнительный таймер, который чистит события scroll каждые 5 секунд
2. Добавить постоянную подписку на все события scroll, обрабатывая каждое изменение положения прокрутки немедленно
3. Применять debounce или throttle для обработчиков прокрутки, снижая частоту вызовов и нагрузку
4. Отказаться от прокрутки и использовать постраничную навигацию с огромными кнопками «Далее» и «Назад»
5. Выделять отдельный DOM-элемент под каждую строку списка, даже если она не видна пользователю

**Выбранный ответ:** 3

Применять debounce или throttle для обработчиков прокрутки, снижая частоту вызовов и нагрузку


**Вопрос: 24**
Оцените влияние Promise и setTimeout в следующем коде. Какие утверждения корректны?

```javascript
console.log(1);
Promise.resolve()
  .then(() => {
    console.log(2);
    return Promise.resolve(3);
  })
  .then(val => {
    console.log(val);
    setTimeout(() => {
      console.log(4);
    }, 0);
  });
setTimeout(() => {
  console.log(5);
}, 0);
console.log(6);
```

**Варианты ответа:**

1. 3 будет выведено синхронно, так как передано напрямую
2. Код может выбросить ошибку, если val окажется undefined
3. 2 и 3 выведутся до 5, потому что Promise.then идёт раньше setTimeout
4. 4 и 5 могут поменяться местами в зависимости от браузера
5. Вложенный setTimeout имеет более высокий приоритет, чем внешний

**Правильный ответ: 3**

**Вопрос: 25**
Для чего используется Code Splitting в Webpack?

**Варианты ответа:**

1. Для автоматической подмены модулей без перезагрузки страницы, улучшая процесс разработки
2. Для сжатия и оптимизации JavaScript-кода перед отправкой в продакшен
3. Для удаления неиспользуемого кода из финального бандла, чтобы уменьшить его размер
4. Для анализа структуры бандла и поиска "тяжёлых" зависимостей
5. Для разделения кода на отдельные файлы и загрузки их по мере необходимости, что снижает время загрузки страницы

**Выбранный ответ:** 5

**Вопрос: 26**
Как создать пользовательское событие и инициировать его вызов на выбранном элементе в DOM?

**Варианты ответа:**

1. Вызвать функцию createCustomEvent('myEvent') для создания и запуска события вручную
2. Создать событие через new Event('myEvent'), и инициировать его на элементе
3. Привязать обработчик через addEventListener('myEvent', callback) без создания события
4. Использовать document.createElement('event') для генерации и работы с пользовательским событием
5. Применить метод document.createAndDispatchEvent('myEvent'), чтобы инициировать пользовательское событие на элементе

**Правильный ответ:** 2

Создать событие через new Event('myEvent'), и инициировать его на элементе

**Вопрос: 27**
При первой загрузке вашего SPA (Single Page Application) критичными являются определённые крупные ресурсы (например, шрифты, изображения, скрипты), отсутствие которых ухудшает пользовательский опыт.
Какой метод вы используете для достижения этой цели?
Варианты ответов:

1. Использование Web Workers для оптимизации загрузки, чтобы обрабатывать фоновые задачи без блокировки основного потока.
2. Отложенная загрузка изображений с помощью Lazy Loading, чтобы загружать изображения только при их появлении в области видимости.
3. Динамическое разделение кода, чтобы загружать только необходимые модули и уменьшить размер бандла.
4. Server-Side Rendering (SSR), чтобы рендерить контент на сервере и ускорять первый рендер страницы.
5. Применение предварительной загрузки (preload) для критичных ресурсов, чтобы загружать важные файлы заранее.

**Выбранный ответ:** 5
5. Применение предварительной загрузки (preload) для критичных ресурсов, чтобы загружать важные файлы заранее.